<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: http::server4::asio::coroutine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classhttp_1_1server4_1_1asio_1_1coroutine.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhttp_1_1server4_1_1asio_1_1coroutine-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">http::server4::asio::coroutine Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides support for implementing stackless coroutines.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for http::server4::asio::coroutine:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhttp_1_1server4_1_1asio_1_1coroutine.png" usemap="#http::server4::asio::coroutine_map" alt=""/>
  <map id="http::server4::asio::coroutine_map" name="http::server4::asio::coroutine_map">
<area href="classhttp_1_1server4_1_1request__parser.html" title="Parser for incoming requests." alt="http::server4::request_parser" shape="rect" coords="0,56,173,80"/>
<area href="classhttp_1_1server4_1_1server.html" title="The top-level coroutine of the HTTP server." alt="http::server4::server" shape="rect" coords="183,56,356,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f28f91711910e94e60c172184ce5e75" id="r_a2f28f91711910e94e60c172184ce5e75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a> ()</td></tr>
<tr class="memdesc:a2f28f91711910e94e60c172184ce5e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a coroutine in its initial state.  <br /></td></tr>
<tr class="separator:a2f28f91711910e94e60c172184ce5e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd466ecc73accfa7bba0a6b3626220" id="r_addbd466ecc73accfa7bba0a6b3626220"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addbd466ecc73accfa7bba0a6b3626220">is_child</a> () const</td></tr>
<tr class="memdesc:addbd466ecc73accfa7bba0a6b3626220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the coroutine is the child of a fork.  <br /></td></tr>
<tr class="separator:addbd466ecc73accfa7bba0a6b3626220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae202c3b2ac8d00ab3777cdc9052cc21" id="r_aae202c3b2ac8d00ab3777cdc9052cc21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae202c3b2ac8d00ab3777cdc9052cc21">is_parent</a> () const</td></tr>
<tr class="memdesc:aae202c3b2ac8d00ab3777cdc9052cc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the coroutine is the parent of a fork.  <br /></td></tr>
<tr class="separator:aae202c3b2ac8d00ab3777cdc9052cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5f23dfaff108e6fb69e412a4f6a39" id="r_ae1b5f23dfaff108e6fb69e412a4f6a39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b5f23dfaff108e6fb69e412a4f6a39">is_complete</a> () const</td></tr>
<tr class="memdesc:ae1b5f23dfaff108e6fb69e412a4f6a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the coroutine has reached its terminal state.  <br /></td></tr>
<tr class="separator:ae1b5f23dfaff108e6fb69e412a4f6a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f28f91711910e94e60c172184ce5e75" id="r_a2f28f91711910e94e60c172184ce5e75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a> ()</td></tr>
<tr class="memdesc:a2f28f91711910e94e60c172184ce5e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a coroutine in its initial state.  <br /></td></tr>
<tr class="separator:a2f28f91711910e94e60c172184ce5e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbd466ecc73accfa7bba0a6b3626220" id="r_addbd466ecc73accfa7bba0a6b3626220"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addbd466ecc73accfa7bba0a6b3626220">is_child</a> () const</td></tr>
<tr class="memdesc:addbd466ecc73accfa7bba0a6b3626220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the coroutine is the child of a fork.  <br /></td></tr>
<tr class="separator:addbd466ecc73accfa7bba0a6b3626220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae202c3b2ac8d00ab3777cdc9052cc21" id="r_aae202c3b2ac8d00ab3777cdc9052cc21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae202c3b2ac8d00ab3777cdc9052cc21">is_parent</a> () const</td></tr>
<tr class="memdesc:aae202c3b2ac8d00ab3777cdc9052cc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the coroutine is the parent of a fork.  <br /></td></tr>
<tr class="separator:aae202c3b2ac8d00ab3777cdc9052cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5f23dfaff108e6fb69e412a4f6a39" id="r_ae1b5f23dfaff108e6fb69e412a4f6a39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1b5f23dfaff108e6fb69e412a4f6a39">is_complete</a> () const</td></tr>
<tr class="memdesc:ae1b5f23dfaff108e6fb69e412a4f6a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the coroutine has reached its terminal state.  <br /></td></tr>
<tr class="separator:ae1b5f23dfaff108e6fb69e412a4f6a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab0e9be6e32c10d8c4b249e099d0fb974" id="r_ab0e9be6e32c10d8c4b249e099d0fb974"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e9be6e32c10d8c4b249e099d0fb974">detail::coroutine_ref</a></td></tr>
<tr class="separator:ab0e9be6e32c10d8c4b249e099d0fb974"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides support for implementing stackless coroutines. </p>
<p>The <code>coroutine</code> class may be used to implement stackless coroutines. The class itself is used to store the current state of the coroutine.</p>
<p>Coroutines are copy-constructible and assignable, and the space overhead is a single int. They can be used as a base class:</p>
<div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classsession.html">session</a> : <a class="code hl_function" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a></div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">}; </div>
<div class="ttc" id="aclasshttp_1_1server4_1_1asio_1_1coroutine_html_a2f28f91711910e94e60c172184ce5e75"><div class="ttname"><a href="#a2f28f91711910e94e60c172184ce5e75">http::server4::asio::coroutine::coroutine</a></div><div class="ttdeci">coroutine()</div><div class="ttdoc">Constructs a coroutine in its initial state.</div><div class="ttdef"><b>Definition</b> request_parser.cpp:246</div></div>
<div class="ttc" id="aclasssession_html"><div class="ttname"><a href="classsession.html">session</a></div><div class="ttdef"><b>Definition</b> server.cpp:122</div></div>
</div><!-- fragment --><p>or as a data member:</p>
<div class="fragment"><div class="line"> <span class="keyword">class </span><a class="code hl_class" href="classsession.html">session</a></div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  <a class="code hl_function" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a> coro_;</div>
<div class="line">}; </div>
</div><!-- fragment --><p>or even bound in as a function argument using lambdas or <code>bind()</code>. The important thing is that as the application maintains a copy of the object for as long as the coroutine must be kept alive.</p>
<dl class="section user"><dt>Pseudo-keywords</dt><dd></dd></dl>
<p>A coroutine is used in conjunction with certain "pseudo-keywords", which are implemented as macros. These macros are defined by a header file:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="yield_8hpp.html">asio/yield.hpp</a>&gt;</span></div>
<div class="ttc" id="ayield_8hpp_html"><div class="ttname"><a href="yield_8hpp.html">yield.hpp</a></div></div>
</div><!-- fragment --><p>and may conversely be undefined as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unyield_8hpp.html">asio/unyield.hpp</a>&gt;</span></div>
<div class="ttc" id="aunyield_8hpp_html"><div class="ttname"><a href="unyield_8hpp.html">unyield.hpp</a></div></div>
</div><!-- fragment --><p><b>reenter</b></p>
<p>The <code>reenter</code> macro is used to define the body of a coroutine. It takes a single argument: a pointer or reference to a coroutine object. For example, if the base class is a coroutine object you may write:</p>
<div class="fragment"><div class="line"> <a class="code hl_define" href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a> (<span class="keyword">this</span>)</div>
<div class="line">{</div>
<div class="line">  ... <a class="code hl_function" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a> body ...</div>
<div class="line">} </div>
<div class="ttc" id="ayield_8hpp_html_a845826f234aec2b016cac4e60aff9bb5"><div class="ttname"><a href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a></div><div class="ttdeci">#define reenter(c)</div><div class="ttdef"><b>Definition</b> yield.hpp:14</div></div>
</div><!-- fragment --><p>and if a data member or other variable you can write:</p>
<div class="fragment"><div class="line"> <a class="code hl_define" href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a> (coro_)</div>
<div class="line">{</div>
<div class="line">  ... <a class="code hl_function" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a> body ...</div>
<div class="line">} </div>
</div><!-- fragment --><p>When <code>reenter</code> is executed at runtime, control jumps to the location of the last <code>yield</code> or <code>fork</code>.</p>
<p>The coroutine body may also be a single statement, such as:</p>
<div class="fragment"><div class="line"> <a class="code hl_define" href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a> (<span class="keyword">this</span>) for (;;)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">} </div>
</div><!-- fragment --><p><b>Limitation:</b> The <code>reenter</code> macro is implemented using a switch. This means that you must take care when using local variables within the coroutine body. The local variable is not allowed in a position where reentering the coroutine could bypass the variable definition.</p>
<p><b>yield <em>statement</em></b></p>
<p>This form of the <code>yield</code> keyword is often used with asynchronous operations:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a> socket_-&gt;async_read_some(<a class="code hl_typedef" href="glad_8h.html#a7fc54503e1a1cf98d128b839ebc0b4d0">buffer</a>(*buffer_), *<span class="keyword">this</span>); </div>
<div class="ttc" id="aglad_8h_html_a7fc54503e1a1cf98d128b839ebc0b4d0"><div class="ttname"><a href="glad_8h.html#a7fc54503e1a1cf98d128b839ebc0b4d0">buffer</a></div><div class="ttdeci">GLenum GLfloat * buffer</div><div class="ttdef"><b>Definition</b> glad.h:2076</div></div>
<div class="ttc" id="ayield_8hpp_html_abaa9287233697b1cd0175180304c7e1d"><div class="ttname"><a href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a></div><div class="ttdeci">#define yield</div><div class="ttdef"><b>Definition</b> yield.hpp:18</div></div>
</div><!-- fragment --><p>This divides into four logical steps:</p>
<ul>
<li><code>yield</code> saves the current state of the coroutine. </li>
<li>The statement initiates the asynchronous operation. </li>
<li>The resume point is defined immediately following the statement. </li>
<li>Control is transferred to the end of the coroutine body.</li>
</ul>
<p>When the asynchronous operation completes, the function object is invoked and <code>reenter</code> causes control to transfer to the resume point. It is important to remember to carry the coroutine state forward with the asynchronous operation. In the above snippet, the current class is a function object object with a coroutine object as base class or data member.</p>
<p>The statement may also be a compound statement, and this permits us to define local variables with limited scope:</p>
<div class="fragment"><div class="line"> <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a></div>
<div class="line">{</div>
<div class="line">  mutable_buffers_1 <a class="code hl_typedef" href="glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a> = <a class="code hl_typedef" href="glad_8h.html#a7fc54503e1a1cf98d128b839ebc0b4d0">buffer</a>(*buffer_);</div>
<div class="line">  socket_-&gt;async_read_some(<a class="code hl_typedef" href="glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a>, *<span class="keyword">this</span>);</div>
<div class="line">} </div>
<div class="ttc" id="aglad_8h_html_a6eba317e3cf44d6d26c04a5a8f197dcb"><div class="ttname"><a href="glad_8h.html#a6eba317e3cf44d6d26c04a5a8f197dcb">b</a></div><div class="ttdeci">GLboolean GLboolean GLboolean b</div><div class="ttdef"><b>Definition</b> glad.h:3074</div></div>
</div><!-- fragment --><p><b>yield return <em>expression</em> ;</b></p>
<p>This form of <code>yield</code> is often used in generators or coroutine-based parsers. For example, the function object:</p>
<div class="fragment"><div class="line"> <span class="keyword">struct </span>interleave : <a class="code hl_function" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a></div>
<div class="line">{</div>
<div class="line">  istream&amp; is1;</div>
<div class="line">  istream&amp; is2;</div>
<div class="line">  <span class="keywordtype">char</span> operator()(<span class="keywordtype">char</span> c)</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_define" href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a> (<span class="keyword">this</span>) for (;;)</div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a> <span class="keywordflow">return</span> is1.get();</div>
<div class="line">      <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a> <span class="keywordflow">return</span> is2.get();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}; </div>
</div><!-- fragment --><p>defines a trivial coroutine that interleaves the characters from two input streams.</p>
<p>This type of <code>yield</code> divides into three logical steps:</p>
<ul>
<li><code>yield</code> saves the current state of the coroutine. </li>
<li>The resume point is defined immediately following the semicolon. </li>
<li>The value of the expression is returned from the function.</li>
</ul>
<p><b>yield ;</b></p>
<p>This form of <code>yield</code> is equivalent to the following steps:</p>
<ul>
<li><code>yield</code> saves the current state of the coroutine. </li>
<li>The resume point is defined immediately following the semicolon. </li>
<li>Control is transferred to the end of the coroutine body.</li>
</ul>
<p>This form might be applied when coroutines are used for cooperative threading and scheduling is explicitly managed. For example:</p>
<div class="fragment"><div class="line"> <span class="keyword">struct </span>task : <a class="code hl_function" href="#a2f28f91711910e94e60c172184ce5e75">coroutine</a></div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordtype">void</span> operator()()</div>
<div class="line">  {</div>
<div class="line">    <a class="code hl_define" href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a> (<span class="keyword">this</span>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">while</span> (... not finished ...)</div>
<div class="line">      {</div>
<div class="line">        ... <span class="keywordflow">do</span> something ...</div>
<div class="line">        <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>;</div>
<div class="line">        ... <span class="keywordflow">do</span> some more ...</div>
<div class="line">        <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">task t1, t2;</div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">  t1();</div>
<div class="line">  t2();</div>
<div class="line">} </div>
</div><!-- fragment --><p><b>yield break ;</b></p>
<p>The final form of <code>yield</code> is used to explicitly terminate the coroutine. This form is comprised of two steps:</p>
<ul>
<li><code>yield</code> sets the coroutine state to indicate termination. </li>
<li>Control is transferred to the end of the coroutine body.</li>
</ul>
<p>Once terminated, calls to <a class="el" href="#ae1b5f23dfaff108e6fb69e412a4f6a39" title="Returns true if the coroutine has reached its terminal state.">is_complete()</a> return true and the coroutine cannot be reentered.</p>
<p>Note that a coroutine may also be implicitly terminated if the coroutine body is exited without a yield, e.g. by return, throw or by running to the end of the body.</p>
<p><b>fork <em>statement</em></b></p>
<p>The <code>fork</code> pseudo-keyword is used when "forking" a coroutine, i.e. splitting it into two (or more) copies. One use of <code>fork</code> is in a server, where a new coroutine is created to handle each client connection:</p>
<div class="fragment"><div class="line"> <a class="code hl_define" href="yield_8hpp.html#a845826f234aec2b016cac4e60aff9bb5">reenter</a> (<span class="keyword">this</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">do</span></div>
<div class="line">  {</div>
<div class="line">    socket_.reset(<span class="keyword">new</span> <a class="code hl_typedef" href="classtcp.html#a6f5bf95251747bb81d75784387938d6a">tcp::socket</a>(my_context_));</div>
<div class="line">    <a class="code hl_define" href="yield_8hpp.html#abaa9287233697b1cd0175180304c7e1d">yield</a> acceptor-&gt;async_accept(*socket_, *<span class="keyword">this</span>);</div>
<div class="line">    <a class="code hl_define" href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a> <a class="code hl_class" href="classhttp_1_1server4_1_1server.html">server</a>(*<span class="keyword">this</span>)();</div>
<div class="line">  } <span class="keywordflow">while</span> (<a class="code hl_function" href="#aae202c3b2ac8d00ab3777cdc9052cc21">is_parent</a>());</div>
<div class="line">  ... <a class="code hl_class" href="classclient.html">client</a>-specific handling follows ...</div>
<div class="line">} </div>
<div class="ttc" id="aclassclient_html"><div class="ttname"><a href="classclient.html">client</a></div><div class="ttdef"><b>Definition</b> async_client.cpp:21</div></div>
<div class="ttc" id="aclasshttp_1_1server4_1_1asio_1_1coroutine_html_aae202c3b2ac8d00ab3777cdc9052cc21"><div class="ttname"><a href="#aae202c3b2ac8d00ab3777cdc9052cc21">http::server4::asio::coroutine::is_parent</a></div><div class="ttdeci">bool is_parent() const</div><div class="ttdoc">Returns true if the coroutine is the parent of a fork.</div><div class="ttdef"><b>Definition</b> request_parser.cpp:252</div></div>
<div class="ttc" id="aclasshttp_1_1server4_1_1server_html"><div class="ttname"><a href="classhttp_1_1server4_1_1server.html">http::server4::server</a></div><div class="ttdoc">The top-level coroutine of the HTTP server.</div><div class="ttdef"><b>Definition</b> server.hpp:29</div></div>
<div class="ttc" id="aclasstcp_html_a6f5bf95251747bb81d75784387938d6a"><div class="ttname"><a href="classtcp.html#a6f5bf95251747bb81d75784387938d6a">tcp::socket</a></div><div class="ttdeci">basic_stream_socket&lt; tcp &gt; socket</div><div class="ttdoc">The TCP socket type.</div><div class="ttdef"><b>Definition</b> tcp.hpp:82</div></div>
<div class="ttc" id="ayield_8hpp_html_ab2e49d0b8dbb3181c7d1f622fd5ea1b4"><div class="ttname"><a href="yield_8hpp.html#ab2e49d0b8dbb3181c7d1f622fd5ea1b4">fork</a></div><div class="ttdeci">#define fork</div><div class="ttdef"><b>Definition</b> yield.hpp:22</div></div>
</div><!-- fragment --><p>The logical steps involved in a <code>fork</code> are:</p>
<ul>
<li><code>fork</code> saves the current state of the coroutine. </li>
<li>The statement creates a copy of the coroutine and either executes it immediately or schedules it for later execution. </li>
<li>The resume point is defined immediately following the semicolon. </li>
<li>For the "parent", control immediately continues from the next line.</li>
</ul>
<p>The functions <a class="el" href="#aae202c3b2ac8d00ab3777cdc9052cc21" title="Returns true if the coroutine is the parent of a fork.">is_parent()</a> and <a class="el" href="#addbd466ecc73accfa7bba0a6b3626220" title="Returns true if the coroutine is the child of a fork.">is_child()</a> can be used to differentiate between parent and child. You would use these functions to alter subsequent control flow.</p>
<p>Note that <code>fork</code> doesn't do the actual forking by itself. It is the application's responsibility to create a clone of the coroutine and call it. The clone can be called immediately, as above, or scheduled for delayed execution using something like <a class="el" href="namespaceasio.html#ab96ddebcabf9c7f1524f803bc063a62b" title="Submits a completion token or function object for execution.">asio::post()</a>.</p>
<dl class="section user"><dt>Alternate macro names</dt><dd></dd></dl>
<p>If preferred, an application can use macro names that follow a more typical naming convention, rather than the pseudo-keywords. These are:</p>
<ul>
<li><code>ASIO_CORO_REENTER</code> instead of <code>reenter</code> </li>
<li><code>ASIO_CORO_YIELD</code> instead of <code>yield</code> </li>
<li><code>ASIO_CORO_FORK</code> instead of <code>fork</code> </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f28f91711910e94e60c172184ce5e75" name="a2f28f91711910e94e60c172184ce5e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f28f91711910e94e60c172184ce5e75">&#9670;&#160;</a></span>coroutine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">http::server4::asio::coroutine::coroutine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a coroutine in its initial state. </p>

</div>
</div>
<a id="a2f28f91711910e94e60c172184ce5e75" name="a2f28f91711910e94e60c172184ce5e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f28f91711910e94e60c172184ce5e75">&#9670;&#160;</a></span>coroutine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">http::server4::asio::coroutine::coroutine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a coroutine in its initial state. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="addbd466ecc73accfa7bba0a6b3626220" name="addbd466ecc73accfa7bba0a6b3626220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbd466ecc73accfa7bba0a6b3626220">&#9670;&#160;</a></span>is_child() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool http::server4::asio::coroutine::is_child </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the coroutine is the child of a fork. </p>

</div>
</div>
<a id="addbd466ecc73accfa7bba0a6b3626220" name="addbd466ecc73accfa7bba0a6b3626220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbd466ecc73accfa7bba0a6b3626220">&#9670;&#160;</a></span>is_child() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool http::server4::asio::coroutine::is_child </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the coroutine is the child of a fork. </p>

</div>
</div>
<a id="ae1b5f23dfaff108e6fb69e412a4f6a39" name="ae1b5f23dfaff108e6fb69e412a4f6a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b5f23dfaff108e6fb69e412a4f6a39">&#9670;&#160;</a></span>is_complete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool http::server4::asio::coroutine::is_complete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the coroutine has reached its terminal state. </p>

</div>
</div>
<a id="ae1b5f23dfaff108e6fb69e412a4f6a39" name="ae1b5f23dfaff108e6fb69e412a4f6a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b5f23dfaff108e6fb69e412a4f6a39">&#9670;&#160;</a></span>is_complete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool http::server4::asio::coroutine::is_complete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the coroutine has reached its terminal state. </p>

</div>
</div>
<a id="aae202c3b2ac8d00ab3777cdc9052cc21" name="aae202c3b2ac8d00ab3777cdc9052cc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae202c3b2ac8d00ab3777cdc9052cc21">&#9670;&#160;</a></span>is_parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool http::server4::asio::coroutine::is_parent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the coroutine is the parent of a fork. </p>

</div>
</div>
<a id="aae202c3b2ac8d00ab3777cdc9052cc21" name="aae202c3b2ac8d00ab3777cdc9052cc21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae202c3b2ac8d00ab3777cdc9052cc21">&#9670;&#160;</a></span>is_parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool http::server4::asio::coroutine::is_parent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the coroutine is the parent of a fork. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ab0e9be6e32c10d8c4b249e099d0fb974" name="ab0e9be6e32c10d8c4b249e099d0fb974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e9be6e32c10d8c4b249e099d0fb974">&#9670;&#160;</a></span>detail::coroutine_ref</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhttp_1_1server4_1_1asio_1_1detail_1_1coroutine__ref.html">detail::coroutine_ref</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Leviathan/lib/asio/src/examples/cpp03/http/server4/<a class="el" href="cpp03_2http_2server4_2request__parser_8cpp.html">request_parser.cpp</a></li>
<li>Leviathan/lib/asio/src/examples/cpp03/http/server4/<a class="el" href="examples_2cpp03_2http_2server4_2server_8cpp.html">server.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehttp.html">http</a></li><li class="navelem"><a class="el" href="namespacehttp_1_1server4.html">server4</a></li><li class="navelem"><a class="el" href="namespacehttp_1_1server4_1_1asio.html">asio</a></li><li class="navelem"><a class="el" href="classhttp_1_1server4_1_1asio_1_1coroutine.html">coroutine</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
